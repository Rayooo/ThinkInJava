## 消息中间件

Message-oriented middleware(MOM) 消息中间件

消息中间件为我们带来了异步的特性，对系统进行了解耦

![MOM.png](MOM.png)

### 消息中间件对系统的解耦

在未引入消息中间件时，若用户登录时，需要发送一条短信，并且记录用户登录的信息（时间，ip等），系统如下

![MOM2.png](MOM2.png)



此时，每增加一个在登录成功后需要被调用的系统，就需要修改登录系统来进行相关的调用，登录系统被迫依赖非常多的系统

引入消息中间件解耦服务调用，如图所示，登录系统负责向消息中间件发送消息，而其他的系统向消息中间件来订阅这个消息，完成自己的工作。登录系统不用关心到底有多少个系统需要直到登录成功这件事，也不用关心如何通知它们，并且各个系统也是互不影响的。

![MOM3.png](MOM3.png)

### 解决消息发送一致性

消息发送一致是指产生消息的业务动作与消息发送的一致，也就是，如果业务操作成功了，那么由这个操作产生的消息一定要发送出去，否则就丢失消息了。另一方面，如果这个业务行为没有发生或者失败，那么就不应该把消息发送出去。

一个解决一致性的方案

1.发送消息给消息中间件

2.消息中间件入库消息

3.消息中间件返回结果

4.业务操作

5.发送业务操作结果给消息中间件

6.更改存储中消息状态

```java
Result postMessage(Message, PostMessageCallback) {
  	//发送消息给消息中间件
  	//获取返回结果
  	//如果失败，返回失败
  	//进行业务操作
  	//获取业务操作结果
  	//发送业务操作结果给消息中间件
  	//返回处理结果
}
```

![MOM4](MOM4.png)

若其中有流程出错了，消息中间件进行反向轮询

![MOM5](MOM5.png)

### 解决消息中间件与使用者的强依赖问题

1.提高消息中间件系统的可靠性，但是没有办法保证百分之百的可靠

2.对于消息中间件系统中影响业务操作进行的部分，使其可靠性与业务自身的可靠性相同

3.可以提供弱依赖的支持，能够较好地保证一致性

主要是从业务数据上进行消息补发，这才是最彻底的容灾手段

### 消息模型对消息接收的影响

Java消息服务（Java Message Service，JMS）

在JSM中，有Queue（点对点）和Topic（发布/订阅）两种模型

Queue模型，Queue里面的消息被一个应用（消费者）处理了，那么其他应用（消费者）是收不到这个消息的，也就是说有连接到这个JMS Queue上的应用共同消费了所有的消息。消息从发送端发送出来的时不确定最终会被哪个应用消费，但是可以明确只有一个应用会去消费这条消息

Topic模型，最大的差别在于消息接收的部分，接收消息的消费者可以收到所有到达Topic的消息的。

### 保证消息可靠性做法

消息存储的可靠性

-   实现基于文件的消息存储（不是很推荐）
-   采用数据库作为消息存储
-   基于双机内存的消息存储

### 消息重复的产生和应对

消息重复有两大类原因

一是消息发送端应用的消息重复发送，消息发送端发送消息给消息中间件，一个解决办法是重试发送消息时使用同样的消息id，而不要在消息中间件上产生消息id。

二是消息到达了消息存储，由消息中间件进行向外的投递时产生重复。这可以用分布式事务解决，但是成本较高，另一种方法是要求消息接收者来处理这种重复的情况，也就是要求消息接收者的消息处理是幂等操作。

JMS的消息确认方式和消息重复的关系

-   AUTO_ACKNOWLEDGE ，自动确认的方式，当JMS的消息接受者收到消息后，JMS的客户端会自动进行消息确认，但是确认时可能消息还没来得及处理或尚未处理完成，所以这种确认方式对于消息投递处理来说是不可靠的。
-   CLIENT_ACKNOWLEDGE，客户端自己确认的方式，也就是说客户端如果要确认消息处理成功，告诉服务端确认信息时，需要主动调用Message接口的acknowledge()方法以进行消息接收成功的确认，这种方式把控制权完全交给了接收消息的客户端应用
-   DUPS_OK_ACKNOWLEDGE，这种方式是在消息接收方的消息处理函数执行结束后进行确认，一方面保证了消息一定是处理结束后才进行确认，另一方面也不需要客户端主动调用Message接口的acknowledge()方法了。

### 消息投递的其他属性支持

消息优先级，一般情况下是先到先投敌，消息优先级的属性可以支持根据优先级来确定投敌顺序，优先级高的消息即使到达消息中间件的时间较晚，也可以被优先调度

订阅者消息处理顺序和分级订阅，一般来说，消息的多个订阅者之间是独立的，它们对消息的处理并不会相互造成影响。不过在一些特殊场景中，对于同样的消息，可能会希望有些订阅者处理结束后再让其他订阅者处理。对于这样的情况，一种方案是可以设定优先处理的订阅集群也就是订阅者消息处理顺序的属性，另一种方案是分级订阅。把优先接收者和一般接受者的接收分开，优先接受者处理成功后主动把消息投递到另外的消息中间件，然后一般接收者接收新产生的消息。

自定义属性，自定义的属性类似于Http的Header，一般是对于这条消息的抽象描述，方便服务端和接收端快速获取这条消息的重要信息。

局部顺序，局部顺序是指在众多的消息中，和某件事情相关的多条消息之间有顺序，而多件事情之间的消息没有顺序，如交易信息，不同人以及一个人的不同交易之间的消息其实是相互无关的，不必保持顺序。但是对于同一笔交易的状态变化所产生的消息，保证其顺序是很有价值的。

### Push和Pull方式的对比

|         | Push                      | Pull                                     |
| ------- | ------------------------- | ---------------------------------------- |
| 数据传输状态  | 保存在服务端                    | 保存在消费端                                   |
| 传输失败，重试 | 服务端需要维护每次传输的状态，遇到失败情况需要重试 | 不需要                                      |
| 数据传输实时性 | 非常实时                      | 默认的短轮询方式的实时性依赖与pull间隔时间，间隔越大实时性越低。长轮询模式的实时性与push一致 |
| 流控机制    | 服务端需要依据订阅者的消费能力做流控        | 消费端可以根据自身消费能力决定是否去Pull消息                 |