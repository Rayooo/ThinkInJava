## 分布式系统介绍

### 线程与进程的执行模式

1.互不通信的多线程模式

2.基于共享容器协同的多线程模式，一个队列用于生产和消费，这个队列就是多个线程会共享的容器或是数据对象，若个线程会并发地访问这个队列。对于线程不安全的容器或对象，需要Copy on Write的方式来控制并发访问

3.通过事件协同的多线程模式，一个线程等待另一个线程的事件，阻塞等待，注意原子性地获取锁，或是调整对多个锁的获取顺序来避免死锁

4.多进程模式，线程是属于进程的，一个进程内的线程共享了进程的内存空间，而多个进程之间的内存空间是独立的。多进程对于单进程多线程的方式来说，资源控制会更容易实现，此外，多进程中的单个进程出现问题，不会造成整体的不可用。多进程之间可以共享数据，但是代价比多线程要大，会涉及序列化和反序列化的开销

### 网络IO实现方式

1.BIO 即Blocking IO，采用阻塞的方式实现。一个socket需要用一个线程来处理，建立连接，读写数据的操作时，会发生阻塞。这个模式好处是简单

2.NIO 即Nonblocking，基于事件驱动思想，采用Reactor模式，不需要为每个socket分配一个线程，可以在一个线程中处理多个socket。Reactor会管理所有的handler，并把出现的事件交给Handler去处理。分发（wait/notify）方式

3.AIO 即AsynchronousIO ，异步IO，AIO采用Proactor模式，AIO在读写操作时，只需要调用相应的read/write方法，并且传入CompletionHandler（动作完成的处理器），在动作完成后，会调用该方法。

### 分布式服务调用

### 分布式系统难点

1.缺乏全局时钟

2.面对故障独立性

3.处理单点故障

4.分布式事务，（两阶段提交2PC，最终一致 等等）

### 解决应用服务器变为集群后的Session问题

Http协议本身是无状态的，需要基于Http协议支持会话状态（Session State）的机制。而这样的机制应该可以使Web服务器从多次单独的HTTP请求中看到会话，知道哪些请求是来自哪个会话。实现方式为，在会话开始时，分配一个唯一的会话表示（Session Id），通过Cookie把这个标示告诉浏览器（Cookie记录JSESSIONID  F67BE568599B32CE37E9015B1BBCAB78），浏览器每次请求都会带上这个会话标识来告诉Web服务器请求是属于哪个会话的。若禁用Cookie，一般做法就是把这个会话标示放到URL参数中。对于集群，如果不做处理，不能保证客户端的每次请求都落在同一边的服务器上，这就是session问题

1.Session Sticky，负载均衡服务器根据每次请求的会话标识来进行请求转发，而Web服务器来说，方案和单机的情况是一样的。但是有以下几个问题，一、如果其中一台Web服务器宕机，那么这台机器的会话数据会丢失。二、会话标识是应用层信息，负载均衡要对应用层进行解析，这个开销比第4层的交换要大。三、负载均衡变成了一个有状态的节点，和无状态的节点相比，内存消耗会更大，容灾方面更麻烦。

2.Session Replication，该方式不再要求负载均衡器来保证多次请求必须同步到一个web服务器上，通过同步保证了不同web服务器之间的Session数据一致，有以下问题，一、同步session数据造成了网络带宽的开销，机器越多，同步数据带来的开销越大。二、每台web服务器都要保存所有session数据，如果整个集群session数很多，每台机器用于保存session数据的内容占用会很严重。

3.session 数据集中储存，将session数据集中存储起来，然后不同web服务器从同样的地方来获取session，如使用 spring session 和 redis ，好处是会话经过负载均衡器不会被固定在同样的web服务器上，而且web服务器之间没有了session复制，session也不保存在本机了。有以下问题，一、读写session引入了网络操作，但是如果是在内网，就问题不大。二、如果如果集中存储session的机器或集群有问题，就会影响应用

4.Cookie Based ，通过Cookie来传递session数据，客户端将Cookie中包含Session的数据包传递到服务器，服务器生成session数据。问题，一、Cookie长度的限制。二、安全性，session数据本来是服务端的数据，而这样传递到了外部网络及客户端。三、带宽消耗。四、性能，每次都要处理Session。

一般来说，使用Session Sticky和Session数据集中存储是比较好的方案