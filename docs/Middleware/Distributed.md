## 分布式系统介绍

### 线程与进程的执行模式

1.互不通信的多线程模式

2.基于共享容器协同的多线程模式，一个队列用于生产和消费，这个队列就是多个线程会共享的容器或是数据对象，若个线程会并发地访问这个队列。对于线程不安全的容器或对象，需要Copy on Write的方式来控制并发访问

3.通过事件协同的多线程模式，一个线程等待另一个线程的事件，阻塞等待，注意原子性地获取锁，或是调整对多个锁的获取顺序来避免死锁

4.多进程模式，线程是属于进程的，一个进程内的线程共享了进程的内存空间，而多个进程之间的内存空间是独立的。多进程对于单进程多线程的方式来说，资源控制会更容易实现，此外，多进程中的单个进程出现问题，不会造成整体的不可用。多进程之间可以共享数据，但是代价比多线程要大，会涉及序列化和反序列化的开销

### 网络IO实现方式

1.BIO 即Blocking IO，采用阻塞的方式实现。一个socket需要用一个线程来处理，建立连接，读写数据的操作时，会发生阻塞。这个模式好处是简单

2.NIO 即Nonblocking，基于事件驱动思想，采用Reactor模式，不需要为每个socket分配一个线程，可以在一个线程中处理多个socket。Reactor会管理所有的handler，并把出现的事件交给Handler去处理。分发（wait/notify）方式

3.AIO 即AsynchronousIO ，异步IO，AIO采用Proactor模式，AIO在读写操作时，只需要调用相应的read/write方法，并且传入CompletionHandler（动作完成的处理器），在动作完成后，会调用该方法。

### 分布式服务调用

### 分布式系统难点

1.缺乏全局时钟

2.面对故障独立性

3.处理单点故障

4.分布式事务，（两阶段提交2PC，最终一致 等等）

### 解决应用服务器变为集群后的Session问题

Http协议本身是无状态的，需要基于Http协议支持会话状态（Session State）的机制。而这样的机制应该可以使Web服务器从多次单独的HTTP请求中看到会话，知道哪些请求是来自哪个会话。实现方式为，在会话开始时，分配一个唯一的会话表示（Session Id），通过Cookie把这个标示告诉浏览器（Cookie记录JSESSIONID  F67BE568599B32CE37E9015B1BBCAB78），浏览器每次请求都会带上这个会话标识来告诉Web服务器请求是属于哪个会话的。若禁用Cookie，一般做法就是把这个会话标示放到URL参数中。对于集群，如果不做处理，不能保证客户端的每次请求都落在同一边的服务器上，这就是session问题

1.Session Sticky，负载均衡服务器根据每次请求的会话标识来进行请求转发，而Web服务器来说，方案和单机的情况是一样的。但是有以下几个问题，一、如果其中一台Web服务器宕机，那么这台机器的会话数据会丢失。二、会话标识是应用层信息，负载均衡要对应用层进行解析，这个开销比第4层的交换要大。三、负载均衡变成了一个有状态的节点，和无状态的节点相比，内存消耗会更大，容灾方面更麻烦。

2.Session Replication，该方式不再要求负载均衡器来保证多次请求必须同步到一个web服务器上，通过同步保证了不同web服务器之间的Session数据一致，有以下问题，一、同步session数据造成了网络带宽的开销，机器越多，同步数据带来的开销越大。二、每台web服务器都要保存所有session数据，如果整个集群session数很多，每台机器用于保存session数据的内容占用会很严重。

3.session 数据集中储存，将session数据集中存储起来，然后不同web服务器从同样的地方来获取session，如使用 spring session 和 redis ，好处是会话经过负载均衡器不会被固定在同样的web服务器上，而且web服务器之间没有了session复制，session也不保存在本机了。有以下问题，一、读写session引入了网络操作，但是如果是在内网，就问题不大。二、如果如果集中存储session的机器或集群有问题，就会影响应用

4.Cookie Based ，通过Cookie来传递session数据，客户端将Cookie中包含Session的数据包传递到服务器，服务器生成session数据。问题，一、Cookie长度的限制。二、安全性，session数据本来是服务端的数据，而这样传递到了外部网络及客户端。三、带宽消耗。四、性能，每次都要处理Session。

一般来说，使用Session Sticky和Session数据集中存储是比较好的方案

### 数据读压力变大

读写分离，缓存热数据，缓存页面

弥补关系型数据库的不足，引入分布式存储系统

专库专用，数据垂直拆封，把数据库中不同的业务数据拆封到不同的数据库中，例如就是把交易，商品，用户数据分开。这样的影响是需要配置多个数据源，增加了所需的配置，不过带来的是每个数据库连接池的隔离。不同业务数据从原来的一个数据库中拆分到了多个数据库中，就要考虑如何处理原来单机中跨业务的事务，一、使用分布式事务，性能明显低于之前的单机事务，二、或是去掉事务或不去追求强事务支持

数据水平拆封，把一个表的数据拆到两个数据库中。产生数据水平拆分的原因是某个业务的数据表的数据量或者更新量到达了单个数据库的瓶颈。水平拆分带来的影响，访问用户信息的应用系统需要解决sql路由的问题，主键的处理也会变得不同，分页也比较难处理。不过一旦能够完成水平拆分，我们将很好地应对数据量及写入量增长的情况。

### 应用

应用拆分，根据业务的特性把应用拆分开，比如说把原来主要功能为三大部分交易，商品和用户拆分成以交易和商品为主的两个应用。这样可以使很大的应用变小。

走服务化的路，系统分成多层，最上端Web系统，用于完成不同的业务功能，中间是服务中心，不同服务中心提供不同的业务服务，最下层是业务的数据库。此时业务功能之间不仅是单机内部的方法调用了，引入了远程的服务调用。其次共享的代码不再是散落在不同的应用中了，这些实现被放在了各个服务中心，数据库连接也发生了一些变化。分团队维护系统，更好地保持稳定性。

### 消息中间件

面向消息的系统（消息中间件）是在分布式系统中完成消息的发送和接收的基础软件

好处是异步和解耦，A和B都和消息中间件打交道，而这两个应用之间并不直接联系，目的是希望收发消息的双方彼此不知道对方的存在，也不受对方影响，所以将消息投递给接收者实际上都采用了异步的方式。