### 运行时数据区域

1.  程序计数器（线程隔离的数据区），可以看作是当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支，循环，跳转，异常处理，线程恢复等基础功能都依赖于程序计数器。
2.  Java虚拟机栈（线程隔离的数据区）线程私有，生命周期与线程相同，描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。
3.  本地方法栈（线程隔离的数据区），它为虚拟机使用到的Native方法服务
4.  Java堆（所有线程共享的数据区），存放对象实例，是垃圾收集器管理的主要区域
5.  方法区（所有线程共享的数据区），储存已被虚拟机加载的类信息，常量，静态变量，即使编译器编译后的代码等数据
6.  运行时常量池，存放编译期生成的各种字面量和符号引用
7.  直接内存

### 垃圾收集器

1.  引用计数算法，给对象中添加一个引用计数器，每当一个地方引用它，计数器值就+1，引用失效时，计数器值就-1，任何时刻计数器为0的对象就是不可能再被使用。这个很难解决对象之间相互循环引用的问题。Java虚拟机没有选用引用计数器算法来管理内存
2.  可达性分析算法，通过一系列成为GC Roots 的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到达GC Roots没有任何引用链相连时，即从GC Roots到这个对象不可达，则证明此对象不可用。

### 引用

1.  强引用，在程序代码中普遍存在的，类似Object o = new Object() 这类引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象
2.  软引用是用来描述一些还有用但非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。
3.  弱引用也是用来描述非必需对象的，但它强度比软引用更弱，被引用关联的对象只能生存到下一次垃圾回收发生之前。当垃圾收集器工作时，无论内存是否足够，都会回收掉只被弱引用关联的对象。
4.  虚引用，是最弱的一种引用关系，一个对象是否具有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

### 垃圾搜集算法

1.  标记-清除算法，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。不足：一，效率问题，标记和清除两个过程效率都不太高。二，空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后程序运行过程中需要分配较大对象时，无法找到足够连续的内存而不得不提前触发另一次垃圾收集动作
2.  复制算法，将可用内存按容量划分成大小相等的两块，每次使用其中的一块，当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样不用考虑内存碎片等复杂情况，实现简单，运行高效，但是代价是将内存缩小到原来的一半（现在的商业虚拟机采用这种算法来回收，但是不是按照1:1比例来划分内存空间，而是8:1左右）
3.  标记-整理算法，过程与标记-清除算法类似，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。
4.  分代收集算法，当前商业虚拟机使用的算法，一般把Java堆分为新生代和老年代，根据各个年代采用最适当的收集算法。新生代每次回收都有大批对象死去，用复制算法。老年代中存活率高，就必须用标记-清理或标记-整理算法

###  内存分配

1.  对象都在堆上分配
2.  对象优先在新生代区域中分配
3.  大对象直接进入老年代（避免分配一群朝生夕灭的短命大对象）
4.  长期存活的对象将进入老年代
5.  动态对象年龄判定，并不是年龄一定要到达MaxTenuringThreshold才能晋升老年代
6.  空间分配担保

### Minor GC、Major GC和Full GC之间的区别

1.  Minor GC，从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。执行 Minor GC 操作时，不会影响到永久代。从永久代到年轻代的引用被当成 GC roots，从年轻代到永久代的引用在标记阶段被直接忽略掉。
2.  Major GC 是清理老年代
3.  Full GC是清理整个堆空间—包括年轻代和老年代。
4.  https://www.zhihu.com/question/41922036